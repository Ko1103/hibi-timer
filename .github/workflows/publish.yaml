name: publish

on:
  workflow_dispatch:
  push:
    branches:
      - main

concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: "--target aarch64-apple-darwin"
            target: darwin
            arch: aarch64
          - platform: macos-latest
            args: "--target x86_64-apple-darwin"
            target: darwin
            arch: x86_64
          - platform: windows-latest
            args: "" # 既定の x86_64-pc-windows-msvc をビルド
            target: windows
            arch: x86_64
    runs-on: ${{ matrix.platform }}
    outputs:
      version: ${{ steps.read_version.outputs.value }}
      artifact-paths: ${{ steps.tauri.outputs.artifactPaths }}
      artifact-files: ${{ steps.collect_artifacts.outputs.files }}

    env:
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: "npm"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          # mac のみクロスターゲット指定（Windows は既定でOK）
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri -> target"

      - name: Install frontend deps
        run: npm ci

      - name: Read app version
        id: read_version
        shell: bash
        run: |
          VERSION=$(node -p "require('./src-tauri/tauri.conf.json').version")
          echo "value=$VERSION" >> "$GITHUB_OUTPUT"

      # --- macOS: 証明書をキーチェーンに取り込み（署名用） ---
      - name: Import Apple Developer Certificate
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          CERT_ID=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -n1 | awk -F'"' '{print $2}')
          echo "APPLE_SIGNING_IDENTITY=$CERT_ID" >> $GITHUB_ENV

      # --- macOS: 公証に使う API Key ファイルを作成 ---
      - name: Write App Store Connect API key
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
        run: |
          echo "$APPLE_API_KEY" > AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8
          echo "APPLE_API_KEY_PATH=$PWD/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8" >> $GITHUB_ENV

      # --- ✅ Windows: 証明書（PFX）をインポートして署名に備える ---
      - name: Import Windows Code Signing Certificate
        if: matrix.platform == 'windows-latest' && env.WINDOWS_CERTIFICATE != ''
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          New-Item -ItemType Directory -Path certificate | Out-Null
          Set-Content -Path certificate\tempCert.txt -Value $env:WINDOWS_CERTIFICATE
          certutil -f -decode certificate\tempCert.txt certificate\codesign.pfx
          Remove-Item certificate\tempCert.txt
          $sec = ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -Force -AsPlainText
          Import-PfxCertificate -FilePath certificate\codesign.pfx -CertStoreLocation Cert:\CurrentUser\My -Password $sec | Out-Null

      # --- ビルド＆リリース作成＆アセットアップロード（公式 tauri-action） ---
      - name: Build & Release
        id: tauri
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # mac 署名・公証
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY_ID }} # Key ID
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }} # .p8 パス
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          # （オプション）Updater 署名を使う場合は以下も設定
          # TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          # TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: ${{ matrix.args }}
          tagName: app-v__VERSION__
          releaseName: "HibiFocus v__VERSION__"
          releaseBody: "Assets からダウンロードしてください。"
          releaseDraft: true
          prerelease: false

      - name: Collect artifacts
        if: steps.tauri.outputs.artifactPaths != ''
        id: collect_artifacts
        shell: bash
        env:
          ARTIFACT_PATHS: ${{ steps.tauri.outputs.artifactPaths }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const dest = path.resolve('release-artifacts');
          fs.mkdirSync(dest, { recursive: true });
          const inputs = (process.env.ARTIFACT_PATHS || '').split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
          const copied = [];
          for (const src of inputs) {
            const fileName = path.basename(src);
            fs.copyFileSync(src, path.join(dest, fileName));
            copied.push(fileName);
            console.log(`Copied ${src} -> ${path.join('release-artifacts', fileName)}`);
          }
          if (copied.length === 0) {
            console.log('No artifacts copied.');
          }
          if (process.env.GITHUB_OUTPUT) {
            fs.appendFileSync(
              process.env.GITHUB_OUTPUT,
              `files<<EOF\n${copied.join('\n')}\nEOF\n`
            );
          }
          NODE

      - name: Upload matrix artifacts
        if: steps.tauri.outputs.artifactPaths != ''
        uses: actions/upload-artifact@v4
        with:
          name: tauri-${{ matrix.target }}-${{ matrix.arch }}
          path: release-artifacts/*
          if-no-files-found: error

  publish-tauri: # Upload artifacts to AWS S3
    runs-on: ubuntu-latest
    needs: build-tauri
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      TAURI_VERSION: ${{ needs.build-tauri.outputs.version }}
      ARTIFACT_PATHS: ${{ needs.build-tauri.outputs.artifact-paths }}
      ARTIFACT_FILES: ${{ needs.build-tauri.outputs.artifact-files }}
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload artifacts to S3
        shell: bash
        run: |
          if [ -z "$ARTIFACT_FILES" ]; then
            echo "No artifact files to upload."
            exit 0
          fi
          python <<'PY'
          import os
          import subprocess
          import sys
          from pathlib import Path

          bucket = os.environ.get('AWS_S3_BUCKET')
          version = os.environ.get('TAURI_VERSION')
          artifact_files = [line.strip() for line in os.environ.get('ARTIFACT_FILES', '').splitlines() if line.strip()]
          if not bucket:
            print('::error::AWS_S3_BUCKET is not set.')
            sys.exit(1)
          if not version:
            print('::error::TAURI_VERSION is not set.')
            sys.exit(1)
          if not artifact_files:
            print('No artifact files provided; nothing to upload.')
            sys.exit(0)

          base_dir = Path('artifacts')
          if not base_dir.exists():
            print(f'::error::{base_dir} does not exist.')
            sys.exit(1)

          for name in artifact_files:
            matches = list(base_dir.rglob(name))
            if not matches:
              print(f'::error::Artifact {name} not found under {base_dir}')
              sys.exit(1)
            artifact_path = str(matches[0])
            for prefix in (f'releases/latest', f'releases/{version}'):
              dest = f's3://{bucket}/{prefix}/{name}'
              print(f'Uploading {artifact_path} -> {dest}')
              subprocess.run(['aws', 's3', 'cp', artifact_path, dest, '--only-show-errors'], check=True)

          PY
