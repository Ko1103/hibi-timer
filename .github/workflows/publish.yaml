name: publish

on:
  workflow_dispatch:
  push:
    branches:
      - main

concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: "--target aarch64-apple-darwin"
            target: darwin
            arch: aarch64
          - platform: macos-latest
            args: "--target x86_64-apple-darwin"
            target: darwin
            arch: x86_64
          - platform: windows-latest
            args: "" # 既定の x86_64-pc-windows-msvc をビルド
            target: windows
            arch: x86_64
    runs-on: ${{ matrix.platform }}

    env:
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: "npm"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          # mac のみクロスターゲット指定（Windows は既定でOK）
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri -> target"

      - name: Read app version
        shell: bash
        run: |
          VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Install frontend deps
        run: npm ci

      # --- macOS: 証明書をキーチェーンに取り込み（署名用） ---
      - name: Import Apple Developer Certificate
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          CERT_ID=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -n1 | awk -F'"' '{print $2}')
          echo "APPLE_SIGNING_IDENTITY=$CERT_ID" >> $GITHUB_ENV

      # --- macOS: 公証に使う API Key ファイルを作成 ---
      - name: Write App Store Connect API key
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
        run: |
          echo "$APPLE_API_KEY" > AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8
          echo "APPLE_API_KEY_PATH=$PWD/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8" >> $GITHUB_ENV

      # --- ✅ Windows: 証明書（PFX）をインポートして署名に備える ---
      - name: Import Windows Code Signing Certificate
        if: matrix.platform == 'windows-latest' && env.WINDOWS_CERTIFICATE != ''
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          New-Item -ItemType Directory -Path certificate | Out-Null
          Set-Content -Path certificate\tempCert.txt -Value $env:WINDOWS_CERTIFICATE
          certutil -f -decode certificate\tempCert.txt certificate\codesign.pfx
          Remove-Item certificate\tempCert.txt
          $sec = ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -Force -AsPlainText
          Import-PfxCertificate -FilePath certificate\codesign.pfx -CertStoreLocation Cert:\CurrentUser\My -Password $sec | Out-Null

      # --- ビルド＆リリース作成＆アセットアップロード（公式 tauri-action） ---
      - name: Build & Release
        id: tauri
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # mac 署名・公証
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY_ID }} # Key ID
          APPLE_API_KEY_PATH: ${{ env.APPLE_API_KEY_PATH }} # .p8 パス
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

          # （オプション）Updater 署名を使う場合は以下も設定
          # TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          # TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: ${{ matrix.args }}
          tagName: app-v__VERSION__
          releaseName: "HibiFocus v__VERSION__"
          releaseBody: "Assets からダウンロードしてください。"
          releaseDraft: true
          prerelease: false
          includeUpdaterJson: true
      - name: Collect artifact paths
        id: artifact_list
        shell: bash
        env:
          TAURI_ARTIFACTS_JSON: ${{ steps.tauri.outputs.artifactPaths }}
        run: |
          set -euo pipefail
          ARTIFACT_DIR="artifacts/${{ matrix.target }}-${{ matrix.arch }}"
          rm -rf "$ARTIFACT_DIR"
          mkdir -p "$ARTIFACT_DIR"
          export ARTIFACT_DIR
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const raw = process.env.TAURI_ARTIFACTS_JSON ?? '[]';
          let paths;
          try {
            paths = JSON.parse(raw);
          } catch (error) {
            console.error('artifactPaths JSON parse error');
            console.error(raw);
            throw error;
          }
          if (!Array.isArray(paths)) {
            console.error('artifactPaths output is not an array');
            process.exit(1);
          }

          const destDir = process.env.ARTIFACT_DIR;
          const ensureCopy = (input) => {
            if (!input) return;
            if (!fs.existsSync(input)) {
              console.warn(`Skipping missing artifact: ${input}`);
              return;
            }
            const dest = path.join(destDir, path.basename(input));
            fs.cpSync(input, dest, { recursive: true });
            console.log(`Copied ${input} -> ${dest}`);
          };

          const extras = [];

          for (const entry of paths) {
            if (!entry) continue;
            ensureCopy(entry);

            const tar = `${entry}.tar.gz`;
            const sig = `${tar}.sig`;

            if (fs.existsSync(tar)) extras.push(tar);
            if (fs.existsSync(sig)) extras.push(sig);
          }

          for (const extra of extras) {
            ensureCopy(extra);
          }
          NODE
          printf 'paths=%s\n' "$ARTIFACT_DIR" >> "$GITHUB_OUTPUT"
      - name: Upload artifacts
        if: steps.artifact_list.outputs.paths != ''
        uses: actions/upload-artifact@v4
        with:
          name: hibi-${{ matrix.target }}-${{ matrix.arch }}
          path: ${{ steps.artifact_list.outputs.paths }}
    outputs:
      version: ${{ env.VERSION }}
      artifact-paths: ${{ steps.artifact_list.outputs.paths }}

  publish-tauri: # Upload artifacts to AWS S3
    runs-on: ubuntu-latest
    needs: build-tauri
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      AWS_S3_PREFIX: ${{ secrets.AWS_S3_PREFIX }}
      APP_VERSION: ${{ needs.build-tauri.outputs.version }}
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          pattern: hibi-*
          merge-multiple: true
          path: artifacts
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Upload artifacts
        shell: bash
        run: |
          aws s3 sync artifacts s3://${{ secrets.AWS_S3_BUCKET }}/${{ secrets.AWS_S3_PREFIX }}/latest --delete
          aws s3 cp artifacts s3://${{ secrets.AWS_S3_BUCKET }}/${{ secrets.AWS_S3_PREFIX }}/${{ env.APP_VERSION }} --recursive
